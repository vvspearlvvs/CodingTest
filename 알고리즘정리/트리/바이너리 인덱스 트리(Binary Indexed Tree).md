<h3>바이너리 인덱스 트리(Binary Indexed Tree) </h3>

2진법 인덱스 구조를 활용해 구간합 문제를 효과적으로 해결할 수 있는 자료구조

정수에 따른 2진수표기

2의보수법에 의해 정수7은 앞에 다 0으로 채워져있고, 뒤에 7를 2진수로 변환해서 사용

-7은 7에서 0을 채워진 값들을 반대로1로 뒤집는다. 

<img src="C:\Users\gg664\AppData\Roaming\Typora\typora-user-images\image-20210708003517065.png" alt="image-20210708003517065" style="zoom:50%;" />

0이 아닌 마지막 비트를 찾을 경우, k&-k를 수행한다. 



**트리구조만들기**

데이터의 개수가 n개라면, n개를 모두 담을 수 있는 배열 필요

이 배열은 바이너리 인덱스 트리에 대한 값의 정보를 담는다.

각각의 인덱스에 대해서

 **0이 아닌 마지막 비트는 해당인덱스가 담고 있는 값들의 개수**를 의미힌다. 

<img src="C:\Users\gg664\AppData\Roaming\Typora\typora-user-images\image-20210708003934784.png" alt="image-20210708003934784" style="zoom:50%;" />

예를 들어, 16같은 경우 0이 아닌 마지막비트가 16

16 인덱스에는 1부터 16까지 모든 데이터에 대한 갑들의 대한 합을 담겠다.(총16개)

8같은 경우 0이 아닌 마지막비트가 8, 1부터8까지 값들의 대한 합을 담고 있다. (총8개)

7같은 경우 0이 아닌 마지막비트가 1, 7자기자신에 대한 정보만 담고 있다.(총1개)

**업데이트하기**

**이떄 특정값을 변경한다면, 0이 아닌 마지막 비트만큼 더하면서 구간들의 값을 변경한다.**

예를 들어 3번쨰 값이 바뀌었따고 하면, 

3같은 경우 0이 아닌 마지막비트가 1이라서, 1칸 이동해 4의 구간들의 값을 변경한다. 

다음 4에서 4칸가서 8에 대한 값을 변경하고, 다음 8에서 8칸가서 16에 대한 값을 변경한다.

![image-20210708004504402](C:\Users\gg664\AppData\Roaming\Typora\typora-user-images\image-20210708004504402.png)

결국 세번쨰 위치에 대한 값의 합정보들을 담고 있는 인덱스들을 뽑게 된다. 



**누적합(prefix sum)**

1부터 N까지 누적합을 구한다면,**0이 아닌 마지막 비트만큼 빼면서 구간들의 값의 합을 계산한다**

예를 들어 1번쨰원소부터 11번째원소까지 누적합을 구한다고 하면,

11(N)부터 출발. 인덱스 11은 11하나에 대한 값의 합을 기억한뒤, 1개 가지고 있어서 1만큼 뺀다. 

1만큼 뺀 인덱스 10에서 9부터 10에 대한 값의 합을 기억한뒤,  2개를 가지고 있어서 2만큼 뺀다.

2만큼 뺀 인덱스 8에서 1부터 8에 대한 값의 합을 기억하면 전체 기억한 값들의 합이 곧 누적합이 된다. 

![image-20210708005029599](C:\Users\gg664\AppData\Roaming\Typora\typora-user-images\image-20210708005029599.png)

결국 1부터 11까지 합정보들을 계산한 값을 뽑게 된다.